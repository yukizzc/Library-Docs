# 1. 协程

## 1.1 async & await关键字 

```python
import asyncio

async def func1():
    print(1)
    await asyncio.sleep(5)
    print(3)

async def func2():
    print(2)
    await asyncio.sleep(5)
    print(4)

tasks = [
    asyncio.ensure_future(func1()),
    asyncio.ensure_future(func2())
    ]
     
loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))
```

注意：遇到IO阻塞自动切换

## 1.2 协程得意义

在一个线程中遇到IO等待时间，线程不会傻傻等待，而会去干其他事



# 2. 异步编程

## 2.1 事件循环

可以理解成一个死循环

```python
import asyncio
# 生成一个事件循环，好比while True        
loop = asyncio.get_event_loop()
# 将任务放到任务列表
loop.run_until_complete(任务)
```

## 2.2 快速上手

协程函数：定义函数时候async def 函数名

协程对象：协程函数（）返回的对象

```python
async def fun():
    pass
result = func()
```

注意：这里函数不会执行，要执行协程函数内代码，必须要将协程对象交给事件循环来处理。

```python
import asyncio
async def fun():
    print('jugeng')
result = fun()
# loop = asyncio.get_event_loop()
# loop.run_until_complete(result)
# python 3.7 以后可以用这种方法代替上面得
asyncio.run(result)
```

## 2.3 await

await + 可等待得对象（协程对象，future对象，task对象 --> IO等待）

示例1：

```python
import asyncio
async def fun():
    print('come')
    response = await asyncio.sleep(2)
    print('over')
asyncio.run(fun())
```

示例2：

```python
import asyncio
async def others():
    print('start')
    await asyncio.sleep(5)
    print('end')
    return '返回值'
async def func():
    print('执行协程内部代码')
    response = await others()
    print('IO请求结束，结果为', response)
asyncio.run(func())
```

示例3：

```python
import asyncio
async def others():
    print('start')
    await asyncio.sleep(5)
    print('end')
    return '返回值'

async def func():
    print('执行协程内部代码')
    # await等执行结束了，执行后面程序
    response1 = await others()
    print('IO请求结束，结果为', response1)
    response2 = await others()
    print('IO请求结束，结果为', response2)
asyncio.run(func())
```

await就是等待对象的计算结果后再执行下去。

## 2.4 Task对象

在事件循环中添加多个任务

Task对象是指：与任务调度，和并发有关，是指帮助在事件循环中并发的向任务列表，添加多个任务。task用于并发调度协程，通过asyncio.create_task(协程对象)的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行，除了使用asyncio.create_task(协程对象)函数（3.7+之后才能使用）外，可以使用loop.create_task()或者ensure_future()，不建议手动实例化Task对象。由于执行时间非常接近，所以看起来像并发。

示例1:

```python
import asyncio
async def func():
    print(1)
    await asyncio.sleep(5)
    print(3)
async def main():
    print('main开始')
    # 创建task对象，把任务添加到事件循环
    task1 = asyncio.create_task(func())
    task2 = asyncio.create_task(func())
    print('main结束')

    ret1 = await task1 
    ret2 = await task2
    print(ret1,ret2)
asyncio.run(main())
```

示例2:(推荐这种方式)

```python
import asyncio
async def func():
    print(1)
    await asyncio.sleep(5)
    print(3)
    return '返回值'
async def main():
    print('main开始')
    # 创建task对象，把任务添加到事件循环
    task_list = [
        asyncio.create_task(func(),name='yan1'),
        asyncio.create_task(func(),name='yan2')
    ]
    print('main结束')

    done,pending = await asyncio.wait(task_list)
    print(done)
asyncio.run(main())
```

